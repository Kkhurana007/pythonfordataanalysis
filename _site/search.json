[
  {
    "objectID": "NumPy.html",
    "href": "NumPy.html",
    "title": "NumPy",
    "section": "",
    "text": "numerical python - function description\nndarray- multidimensional array providing fast arithmetic operations\nmathematical functions\ntools for reading/writing\nlinear algebra, random number generation, fourier transformation\nimport numpy as np\nmy_arr = np.arange(1000000)\nmy_list = list(range(100000))\n%timeit my_arr2 = my_arr * 2\n\n3.91 ms ± 154 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n%timeit my_list2 = [x * 2 for x in my_list]\n\n12.3 ms ± 4.77 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\ndata  = np.array([[1.5, -0.1, 3], [0, -3, 6.5]])\ndata\n\narray([[ 1.5, -0.1,  3. ],\n       [ 0. , -3. ,  6.5]])\ndata * 10\n\narray([[ 15.,  -1.,  30.],\n       [  0., -30.,  65.]])\ndata + data\n\narray([[ 3. , -0.2,  6. ],\n       [ 0. , -6. , 13. ]])\ndata.shape\n\n(2, 3)\ndata.dtype\n\ndtype('float64')\n# creating arrays\n\ndata1 = [6, 7.5, 8, 0, 1]\n\narr1 = np.array(data1)\n\narr1\n\narray([6. , 7.5, 8. , 0. , 1. ])\ndata2 = [[1, 2, 3, 4], [5, 6, 7, 8]]\n\narr2 = np.array(data2)\n\narr2\n\narray([[1, 2, 3, 4],\n       [5, 6, 7, 8]])\narr2.ndim\n\n2\narr2.shape\n\n(2, 4)\narr1.dtype\n\ndtype('float64')\narr2.dtype\n\ndtype('int32')\nnp.zeros(10)\n\narray([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])\nnp.ones((3, 6))\n\narray([[1., 1., 1., 1., 1., 1.],\n       [1., 1., 1., 1., 1., 1.],\n       [1., 1., 1., 1., 1., 1.]])\nnp.empty((2, 3, 2))\nnp.arange(15)\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])"
  },
  {
    "objectID": "NumPy.html#pseudorandom-number-generation",
    "href": "NumPy.html#pseudorandom-number-generation",
    "title": "NumPy",
    "section": "Pseudorandom number generation",
    "text": "Pseudorandom number generation\n\nsamples = np.random.standard_normal(size= (4, 4))\n\nsamples\n\narray([[ 0.26762709, -0.62405293,  0.67249719, -0.46023273],\n       [ 0.40611368, -0.01041362,  0.51275103, -1.95844566],\n       [ 0.90884576, -0.28283029,  0.47254105,  2.20649657],\n       [ 0.69228499, -0.31918775, -0.74474035,  0.28790593]])\n\n\n\nrng = np.random.default_rng(seed = 12334)\n\ndata = rng.standard_normal((2,3))\n\n\ntype(rng)\n\nnumpy.random._generator.Generator\n\n\n\nUniversal Functions : Fast Element-Wise Array Functions\n\nimport numpy as np\nfrom random import normalvariate\narr = np.arange(10)\n\n\nnp.sqrt(arr)\n\narray([0.        , 1.        , 1.41421356, 1.73205081, 2.        ,\n       2.23606798, 2.44948974, 2.64575131, 2.82842712, 3.        ])\n\n\n\nnp.exp(arr)\n\narray([1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01,\n       5.45981500e+01, 1.48413159e+02, 4.03428793e+02, 1.09663316e+03,\n       2.98095799e+03, 8.10308393e+03])\n\n\n\nx = rng.standard_normal(8)\n\ny = rng.standard_normal(8)\n\nx\n\narray([-0.32357072, -1.8494368 , -1.89739205,  0.04315429,  1.01046514,\n       -0.73625393,  0.46616191, -0.09290374])\n\n\n\ny\n\narray([-0.12705798, -0.64476954, -0.62430977,  0.87432098,  1.55273649,\n       -1.53739177, -0.73752509,  0.41995739])\n\n\n\nnp.maximum(x, y)  #based on element wise comparison\n\narray([-0.12705798, -0.64476954, -0.62430977,  0.87432098,  1.55273649,\n       -0.73625393,  0.46616191,  0.41995739])\n\n\n\narr = rng.standard_normal(7) * 5\n\narr\n\narray([-1.61785359, -9.24718402, -9.48696026,  0.21577147,  5.05232568,\n       -3.68126964,  2.33080955])\n\n\n\nremainder, whole_part = np.modf(arr)\n\n\nremainder\n\narray([-0.61785359, -0.24718402, -0.48696026,  0.21577147,  0.05232568,\n       -0.68126964,  0.33080955])\n\n\n\nwhole_part\n\narray([-1., -9., -9.,  0.,  5., -3.,  2.])\n\n\n\narr\n\narray([-1.61785359, -9.24718402, -9.48696026,  0.21577147,  5.05232568,\n       -3.68126964,  2.33080955])\n\n\n\nout = np.zeros_like(arr)\n\n\nnp.add(arr, 1)\n\narray([-0.61785359, -8.24718402, -8.48696026,  1.21577147,  6.05232568,\n       -2.68126964,  3.33080955])\n\n\n\nnp.add(arr, 1, out= out)\n\narray([-0.61785359, -8.24718402, -8.48696026,  1.21577147,  6.05232568,\n       -2.68126964,  3.33080955])\n\n\n\nout\n\narray([-0.61785359, -8.24718402, -8.48696026,  1.21577147,  6.05232568,\n       -2.68126964,  3.33080955])\n\n\n\n\nArray oriented programming with Arrays\n\nvectorization (faster) than pure Python equivalents\n\n\npoints = np.arange(-5, 5, 0.01) #100 equally spaced points\n\nxs, ys = np.meshgrid(points, points)\n\n# numpy.meshgrid function takes two one-dimensional arrays and produces two two-dimensional matrices\n\n\nys\n\narray([[-5.  , -5.  , -5.  , ..., -5.  , -5.  , -5.  ],\n       [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99],\n       [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98],\n       ...,\n       [ 4.97,  4.97,  4.97, ...,  4.97,  4.97,  4.97],\n       [ 4.98,  4.98,  4.98, ...,  4.98,  4.98,  4.98],\n       [ 4.99,  4.99,  4.99, ...,  4.99,  4.99,  4.99]])\n\n\n\nz = np.sqrt (xs ** 2 + ys ** 2)\n\nz\n\narray([[7.07106781, 7.06400028, 7.05693985, ..., 7.04988652, 7.05693985,\n        7.06400028],\n       [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,\n        7.05692568],\n       [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,\n        7.04985815],\n       ...,\n       [7.04988652, 7.04279774, 7.03571603, ..., 7.0286414 , 7.03571603,\n        7.04279774],\n       [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,\n        7.04985815],\n       [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,\n        7.05692568]])\n\n\n\n# visualizations with 2-d arrays\n\nimport matplotlib.pyplot as plt\n\nplt.imshow(z, cmap = plt.cm.gray, extent = [-5, 5, -5, 5])\n\nplt.colorbar()\n\nplt.title(\"Image plot $\\sqrt{x^2 + y^2}$ for a grid of values\")\n\nText(0.5, 1.0, 'Image plot $\\\\sqrt{x^2 + y^2}$ for a grid of values')\n\n\n\n\n\n\nplt.close('all')\n\n\n\nExpressing Conditional Logic as Array Operations\n\nxarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])\n\nyarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])\n\ncond = np.array([True, False, True, True, False])\n\n\n# take value form xarr whenever true, otherwise take value from yarr\n\nresult = [(x if c else y)\n         for x, y, c in zip (xarr, yarr, cond)]\n\n\nresult\n\n[1.1, 2.2, 1.3, 1.4, 2.5]\n\n\n\n\nnumpy.where\n\n# numpy.where (replace all positive values with 2 and negative with -2)\n\narr = rng.standard_normal((4, 4))\n\narr\n\narray([[-0.09290374, -0.12705798, -0.64476954, -0.62430977],\n       [ 0.87432098,  1.55273649, -1.53739177, -0.73752509],\n       [ 0.41995739, -0.93658739,  0.62072248,  0.81057914],\n       [-0.21398203,  0.67748945, -1.54002066, -0.9638457 ]])\n\n\n\narr &gt; 0\n\narray([[False, False, False, False],\n       [ True,  True, False, False],\n       [ True, False,  True,  True],\n       [False,  True, False, False]])\n\n\n\nnp.where (arr  &gt; 0, 2, -2)\n\narray([[-2, -2, -2, -2],\n       [ 2,  2, -2, -2],\n       [ 2, -2,  2,  2],\n       [-2,  2, -2, -2]])\n\n\n\n# or set only the positive values to 2\n\nnp.where (arr &gt; 0, 2, arr)\n\narray([[-0.09290374, -0.12705798, -0.64476954, -0.62430977],\n       [ 2.        ,  2.        , -1.53739177, -0.73752509],\n       [ 2.        , -0.93658739,  2.        ,  2.        ],\n       [-0.21398203,  2.        , -1.54002066, -0.9638457 ]])\n\n\n\n\nmathematical and statistical methods\n\narr = rng.standard_normal ((5, 4))\n\narr\n\narray([[-0.64316368, -0.48860061, -1.41271857, -0.10120962],\n       [-0.70385422,  2.41319157, -0.54405393, -0.90339244],\n       [ 0.82712685, -0.62647321, -0.13480887,  0.03956079],\n       [ 0.56044129,  0.34237924, -0.6576538 ,  1.04696188],\n       [ 0.17595271, -1.13639865, -0.54922125,  0.70725439]])\n\n\n\narr.mean()\n\n-0.08943400646176203\n\n\n\nnp.mean(arr)\n\n-0.08943400646176203\n\n\n\narr.sum()\n\n-1.7886801292352406\n\n\n\narr.mean(axis = 1) # columns\n\narray([-0.66142312,  0.06547274,  0.02635139,  0.32303215, -0.2006032 ])\n\n\n\narr.sum(axis = 1)\n\narray([-2.64569248,  0.26189098,  0.10540556,  1.29212861, -0.8024128 ])\n\n\n\narr = np.array([0,1,2,3,4,5,6,7])\n\narr.cumsum()\n\narray([ 0,  1,  3,  6, 10, 15, 21, 28])\n\n\n\narr = np.array([[0,1,2], [3, 4, 5], [6, 7, 8]])\n\n\narr\n\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])\n\n\n\n# arr.cumsum(axis = 0 ) computes the cumulative sum along rows\n\n# arr.sumsum (axis= 1) computes the sum along columns\n\narr.cumsum(axis = 0)\n\narray([[ 0,  1,  2],\n       [ 3,  5,  7],\n       [ 9, 12, 15]])\n\n\n\narr.cumsum(axis = 1)\n\narray([[ 0,  1,  3],\n       [ 3,  7, 12],\n       [ 6, 13, 21]])\n\n\n\n\nmethods for boolean arrays\n\narr = rng.standard_normal(100)\n\n(arr&gt; 0).sum()\n\n41\n\n\n\n(arr &lt;= 0).sum()   #all non-po\n\n59\n\n\n\n\nSorting\n\narr = rng.standard_normal(6)\n\narr\n\narray([ 0.81272428, -0.67629236,  0.09344394, -0.20621744,  0.10364886,\n        0.70966403])\n\n\n\narr.sort()\n\n\narr\n\narray([-0.67629236, -0.20621744,  0.09344394,  0.10364886,  0.70966403,\n        0.81272428])\n\n\n\narr = rng.standard_normal((5, 3))\n\narr\n\narray([[-1.58684863, -0.1143117 ,  2.38420916],\n       [-0.64811009,  1.31931176,  0.01123432],\n       [-0.90663373, -0.96531814,  0.46431808],\n       [ 0.52164015, -0.08486576, -0.98397298],\n       [ 0.09054187, -1.08417551, -0.48832961]])\n\n\n\narr.sort (axis = 0)  #sorts the values across columns\n\narr\n\narray([[-1.58684863, -1.08417551, -0.98397298],\n       [-0.96531814, -0.90663373, -0.48832961],\n       [-0.64811009, -0.1143117 ,  0.01123432],\n       [-0.08486576,  0.09054187,  0.46431808],\n       [ 0.52164015,  1.31931176,  2.38420916]])\n\n\n\narr.sort (axis = 1) \n\narr\n\narray([[-1.58684863, -1.08417551, -0.98397298],\n       [-0.96531814, -0.90663373, -0.48832961],\n       [-0.64811009, -0.1143117 ,  0.01123432],\n       [-0.08486576,  0.09054187,  0.46431808],\n       [ 0.52164015,  1.31931176,  2.38420916]])\n\n\n\narr2 = np.array([5, -10, 7, 1, 0, -3])\n\n\nsorted_arr2 = np.sort(arr2)\n\nsorted_arr2\n\narray([-10,  -3,   0,   1,   5,   7])\n\n\n\n\nunique and other set logic\n\nnames\n\narray(['bob', 'joe', 'will', 'zhou', 'lu', 'wei', 'rajwinder'],\n      dtype='&lt;U9')\n\n\n\nnp.unique(names)\n\narray(['bob', 'joe', 'lu', 'rajwinder', 'wei', 'will', 'zhou'],\n      dtype='&lt;U9')\n\n\n\nnp.append(names, 'lu')\n\narray(['bob', 'joe', 'will', 'zhou', 'lu', 'wei', 'rajwinder', 'lu'],\n      dtype='&lt;U9')\n\n\n\n# we've 'lu' twice now, let's see now unique\n\n# sorting done aswell\n\nnp.unique(names)\n\narray(['bob', 'joe', 'lu', 'rajwinder', 'wei', 'will', 'zhou'],\n      dtype='&lt;U9')\n\n\n\n# python alternative\n\nsorted(set(names))\n\n['bob', 'joe', 'lu', 'rajwinder', 'wei', 'will', 'zhou']\n\n\n\n\narray set operations\n\n# numpy.in1d for testing memebership of the values in one array\n\nvalues = np.array([6, 0,0,0,3,2])\n\nnp.in1d(values, [1,2,3])\n\narray([False, False, False, False,  True,  True])\n\n\n\n\nfile input and output\n\narr = np.arange(10)\n\n\nnp.save('some_array', arr)\n\n\nnp.load('some_array.npy')\n\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n\n\n# save multiple arrays using  np.savez\nnp.savez('array_archive.npz', a = arr, b=arr)\n\n\narch = np.load(\"array_archive.npz\")\n\n\narch['b']\n\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n\n\n# saving in compressed format\n\nnp.savez_compressed('arrays_compressed.npz', a= arr, b= arr)"
  },
  {
    "objectID": "NumPy.html#linear-alzerba",
    "href": "NumPy.html#linear-alzerba",
    "title": "NumPy",
    "section": "Linear Alzerba",
    "text": "Linear Alzerba\n\nx = np.array([[1, 2, 3], [4, 5, 6]])\n\ny = np.array([[6, 23], [-1, 7], [8,9]])\n\nx\n\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\n\ny\n\narray([[ 6, 23],\n       [-1,  7],\n       [ 8,  9]])\n\n\n\nx.dot(y)\n\narray([[ 28,  64],\n       [ 67, 181]])\n\n\n\n# equivalent to\n\nnp.dot(x, y)\n\narray([[ 28,  64],\n       [ 67, 181]])\n\n\n\n# product of 1d and 2d array\nx @ np.ones(3)\n\narray([ 6., 15.])\n\n\n\n# numpy.linalg (matrix decompositions)\n\nfrom numpy.linalg import inv, qr\n\nX = rng.standard_normal((5, 5))\n\nmat = X.T @ X\n\n\nmat\n\narray([[ 5.79511464, -3.30831545, -2.66542844, -0.61858429, -4.34315368],\n       [-3.30831545,  6.04913293,  1.09484984, -0.88187098,  3.79344801],\n       [-2.66542844,  1.09484984,  3.59693921, -0.10949232,  1.50109261],\n       [-0.61858429, -0.88187098, -0.10949232,  0.68764721,  0.24806815],\n       [-4.34315368,  3.79344801,  1.50109261,  0.24806815,  4.09980802]])\n\n\n\ninv(mat)\n\narray([[ 1.95391205,  0.4259796 ,  0.86161239,  1.99396982,  1.23962108],\n       [ 0.4259796 ,  1.84110512,  0.55359754,  3.43225775, -1.66263314],\n       [ 0.86161239,  0.55359754,  0.79117237,  1.60608307,  0.01366661],\n       [ 1.99396982,  3.43225775,  1.60608307,  8.69084511, -2.17736422],\n       [ 1.23962108, -1.66263314,  0.01366661, -2.17736422,  3.22224774]])\n\n\n\nmat @ inv(mat)\n\narray([[ 1.00000000e+00,  7.37690538e-17,  8.63526934e-17,\n         2.45602532e-16,  5.57110698e-16],\n       [ 3.59505366e-17,  1.00000000e+00, -1.43602651e-16,\n         1.56181454e-15, -8.26684003e-16],\n       [-2.51848975e-16, -9.56323491e-18,  1.00000000e+00,\n        -7.81952475e-16, -4.32942875e-16],\n       [-1.22081410e-16,  5.77266093e-17, -3.23653576e-16,\n         1.00000000e+00, -9.26541377e-18],\n       [-4.93401745e-16,  1.63171237e-15, -7.64319458e-17,\n         1.26774536e-15,  1.00000000e+00]])"
  },
  {
    "objectID": "NumPy.html#random-walks",
    "href": "NumPy.html#random-walks",
    "title": "NumPy",
    "section": "Random walks",
    "text": "Random walks\n\n# with python\n\nimport random\nposition = 0\nwalk = [position]\nnsteps = 1000\n\nfor _ in range(nsteps):\n    step = 1 if random.randint(0, 1) else -1\n    position += step\n    walk.append (position)\n\n\nplt.plot(walk[:100])\n\n\n\n\n\n# with numpy\n\nnsteps = 1000\n\nrng = np.random.default_rng (seed = 12345)\n\ndraws = rng.integers(0, 2, size= nsteps)\nsteps = np.where(draws == 0, 1, -1)\n\nwalk = steps.cumsum()\n\n\nwalk.min()\n\n-8\n\n\n\nwalk.max()\n\n50\n\n\n\n(np.abs(walk) &gt;= 10).argmax()\n\n155\n\n\n\n# simulting many random walks at once with numpy\n\n\nnwalks = 5000\n\nnsteps = 1000\n\ndraws = rng.integers(0, 2, size = (nwalks, nsteps))\n\nsteps = np.where(draws &gt; 0, 1, -1)\n\nwalks = steps.cumsum(axis = 1)\n\nwalks\n\narray([[  1,   2,   1, ..., -24, -25, -26],\n       [ -1,   0,  -1, ...,  -2,  -1,   0],\n       [  1,   0,   1, ..., -22, -23, -24],\n       ...,\n       [  1,   0,   1, ...,   0,   1,   0],\n       [ -1,  -2,  -3, ...,  78,  77,  78],\n       [  1,   2,   1, ..., -42, -41, -40]])\n\n\n\nwalks.max()\n\n143\n\n\n\nwalks.min()\n\n-125\n\n\n\n# any method to check for details\n\nhits30 = (np.abs(walks) &gt;=30).any(axis = 1)\n\nhits30\n\narray([ True, False,  True, ..., False,  True,  True])\n\n\n\nhits30.sum()\n\n3314\n\n\n\ncrossing_times = (np.abs(walks[hits30]) &gt;= 30).argmax(axis = 1)\n\ncrossing_times\n\narray([897, 187, 607, ..., 497, 363, 337], dtype=int64)\n\n\n\n# average minimum crossing time\n\ncrossing_times.mean()\n\n503.8135184067592\n\n\n\ndraws = 0.25 * rng.standard_normal((nwalks, nsteps))\n\ndraws\n\narray([[-0.08138429, -0.04475884, -0.38321311, ..., -0.03139133,\n        -0.30425572,  0.18290185],\n       [ 0.01076688,  0.14528523, -0.03114483, ...,  0.64561549,\n        -0.39630438, -0.06154916],\n       [-0.04661326, -0.37844207,  0.41350618, ...,  0.12811076,\n        -0.04412827, -0.1934124 ],\n       ...,\n       [ 0.06564597, -0.34394821,  0.48579642, ...,  0.21045964,\n         0.32496219,  0.24889926],\n       [-0.22382603,  0.25768943,  0.20307599, ..., -0.05329224,\n        -0.02358867, -0.08702334],\n       [ 0.07009196, -0.10779262, -0.37344277, ..., -0.10002413,\n         0.25685768, -0.32743117]])"
  }
]